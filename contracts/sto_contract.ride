{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let managementAddressPubkey = base58'D_MANAGEMENT_PUBKEY'
let coldVault = extract(addressFromString("D_COLD_VAULT_ADDR"))
let token = base58'D_ASSET_ID'
let tokenRate = D_RATE
let softCapWaves = D_SOFT_CAP_WAVES
let hardCapWaves = D_HARD_CAP_WAVES
let minInvestmentWaves = D_MIN_INVESTMENT
let maxInvestmentWaves = D_MAX_INVESTMENT
let startHeight = D_START_DATE
let endHeight = D_FINISH_DATE
let whitelist = D_WHITELIST

 
@Callable(i)
func buyTokens() = {
    let currentInvestor = i.caller.bytes
   
    let sendedAmount = extract(i.payment).amount
    if (sendedAmount <= 0) then throw("Cannot accept zero value payments")
    else if (sendedAmount < minInvestmentWaves) then throw("Attached payment is below minimal price")
    else if (sendedAmount > maxInvestmentWaves) then throw("Attached payment is above maximum price")
    else if (height < startHeight) then throw("STO is not started yet")
    else if (height > endHeight) then throw("STO is already finished")
    else {
        let wavesRaised = wavesBalance(coldVault)
        if ((wavesRaised + sendedAmount) >= hardCapWaves) then 
            throw("Attached payment overflows hardcap")
        else {
            let tokenAmount = (sendedAmount / tokenRate)

            TransferSet([
                ScriptTransfer(coldVault, sendedAmount, unit),
                ScriptTransfer(i.caller, tokenAmount, token)
            ])
        }
    }
}

@Callable(i)
func finalize() = {
    let isReachedSoftCap = wavesBalance(this) >= softCapWaves
    let stoFinished = height >= endHeight
    if (isReachedSoftCap || stoFinished) then {
      WriteSet([
        DataEntry("finalized", true)
      ])
    }
    else
        throw("STO not finished yet")
}

@Callable(i)
func setStartTime(newStartTime: Int) = {
    if (newStartTime > endHeight) then throw("Start date must be lower than end date")
    # else if (newStartTime <= height) then throw("Cannot set time to past")
    else {
        WriteSet([
          DataEntry("startHeight", newStartTime)
        ])
    }
}

@Callable(i)
func setEndTime(newEndTime: Int) = {
    if (newEndTime < startHeight) then throw("End date must be higher than start date")
    else if (newEndTime <= height) then throw("Cannot set time to past")
    else {
        WriteSet([
          DataEntry("endHeight", newEndTime)
        ])
    }
}

@Callable(i)
func setStartAndEndTimes(newStartTime: Int, newEndTime: Int) = {
    if (newStartTime > endHeight) then throw("Start date must be lower than end date")
    else if (newEndTime < startHeight) then throw("End date must be higher than start date")
    # else if ((newStartTime <= height) then throw("Cannot set time to past")
    else if (newEndTime <= height) then throw("Cannot set time to past")
    else {  
        WriteSet([
            DataEntry("startDate", newStartTime),
            DataEntry("endDate", newEndTime)
        ])
    }
}

@Callable(i)
func setMinInvestment(newValue: Int) = {
    WriteSet([
      DataEntry("minInvestment", newValue)
    ])
}

@Callable(i)
func setMaxInvestment(newValue: Int) = {
  WriteSet([
    DataEntry("maxInvestment", newValue)
  ])
}

@Callable(i)
func setWhitelistAddresses(investors: String) = {
    WriteSet([
      DataEntry("whitelistedInvestors", investors)
    ])
}

@Callable(i)
func addToWhitelist(investor: String) = {
    let primaryKey = "whitelistedInvestor"
    let fullKey = primaryKey + "-" + investor
    WriteSet([
        DataEntry(fullKey, true)
    ])
}

@Callable(i)
func removeFromWhitelist(investor: String) = {
    let primaryKey = "whitelistedInvestor"
    let fullKey = primaryKey + "-" + investor
    WriteSet([
        DataEntry(fullKey, false)
    ])
}