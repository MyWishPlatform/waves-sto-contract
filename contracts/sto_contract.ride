{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let managementAddress = base58'D_MANAGEMENT_ADDR'
let coldVault = extract(addressFromString("D_COLD_VAULT_ADDR"))
let token = base58'D_ASSET_ID'
let tokenRate = D_RATE
let softCapWaves = D_SOFT_CAP_WAVES
let hardCapWaves = D_HARD_CAP_WAVES
let minInvestmentWaves = D_MIN_INVESTMENT
let maxInvestmentWaves = D_MAX_INVESTMENT
let startHeight = D_START_DATE
let endHeight = D_FINISH_DATE
let whitelist = D_WHITELIST

 
@Callable(i)
func buyTokens() = {
    let investorAddress = toBase58String(i.caller.bytes)
    let whitelistString = getStringValue(this, "whitelistedInvestors")
    let listIndex = indexOf(whitelistString, investorAddress)
    if listIndex == unit then throw("Only for whitelisted")
    else {
        let sendedAmount = extract(i.payment).amount
        if (sendedAmount <= 0) then throw("Cannot accept zero value payments")
        else if (sendedAmount < minInvestmentWaves) then throw("Attached payment is below minimal price")
        else if (sendedAmount > maxInvestmentWaves) then throw("Attached payment is above maximum price")
        else if (height < startDate) then throw("STO is not started yet")
        else if (height > endDate) then throw("STO is already finished")
        else {
            let wavesRaised = wavesBalance(coldVault)
            if ((wavesRaised + sendedAmount) >= hardCapWaves) then 
                throw("Attached payment overflows hardcap")
            else {
                let tokenAmount = (sendedAmount / tokenRate)

                TransferSet([
                    ScriptTransfer(coldVault, sendedAmount, unit),
                    ScriptTransfer(i.caller, tokenAmount, token)
                ])
            }
        }
    }
}

@Callable(i)
func finalize() = {
    let caller = toBase58String(i.caller.bytes)
    if caller != toBase58String(managementAddress) then {
        throw("Only for administration")
    } else {
        let isReachedSoftCap = wavesBalance(coldVault) >= softCapWaves
        let stoFinished = height >= endDate
        if (isReachedSoftCap || stoFinished) then {
            WriteSet([
                DataEntry("finalized", true)
            ])
        } else {
            throw("STO not finished yet")
        }
    }
}

@Callable(i)
func setStartTime(newStartTime: Int) = {
    if (newStartTime > endHeight) then throw("Start date must be lower than end date")
    # else if (newStartTime <= height) then throw("Cannot set time to past")
    else {
        WriteSet([
          DataEntry("startHeight", newStartTime)
        ])
    }
}

@Callable(i)
func setEndTime(newEndTime: Int) = {
    if (newEndTime < startHeight) then throw("End date must be higher than start date")
    else if (newEndTime <= height) then throw("Cannot set time to past")
    else {
        WriteSet([
          DataEntry("endHeight", newEndTime)
        ])
    }
}

@Callable(i)
func setStartAndEndTimes(newStartTime: Int, newEndTime: Int) = {
    if (newStartTime > endHeight) then throw("Start date must be lower than end date")
    else if (newEndTime < startHeight) then throw("End date must be higher than start date")
    # else if ((newStartTime <= height) then throw("Cannot set time to past")
    else if (newEndTime <= height) then throw("Cannot set time to past")
    else {  
        WriteSet([
            DataEntry("startDate", newStartTime),
            DataEntry("endDate", newEndTime)
        ])
    }
}

@Callable(i)
func setMinInvestment(newValue: Int) = {
    WriteSet([
      DataEntry("minInvestment", newValue)
    ])
}

@Callable(i)
func setMaxInvestment(newValue: Int) = {
  WriteSet([
    DataEntry("maxInvestment", newValue)
  ])
}

@Callable(i)
func setWhitelistAddresses(investors: String) = {
    let whitelistDataKey = "whitelistedInvestors"
    let whitelist = split(investors, ",")
    let whitelistSize = size(whitelist)
    let totalInvKey = "totalInvestors"

    WriteSet([
      DataEntry(whitelistDataKey, investors),
      DataEntry(totalInvKey, whitelistSize)
    ])
}


@Callable(i)
func addToWhitelist(investor: String) = {
    let statePrefix = "whitelistedInvestor"
    let stateKey = statePrefix + "-" + investor
    let whitelistDataKey = "whitelistedInvestors"
    let whitelistString = getStringValue(this, whitelistDataKey)
    let totalInvKey = "totalInvestors"

    if (isDefined(whitelistString))
    then {
        let whitelist = split(whitelistString, ",")
        let newWhitelistString = whitelistString + "," + investor

        WriteSet([
            DataEntry(stateKey, true),
            DataEntry(totalInvKey, size(whitelist) + 1),
            DataEntry(whitelistDataKey, newWhitelistString)
        ])
    }
    else {
        WriteSet([
            DataEntry(stateKey, true),
            DataEntry(totalInvKey, 1),
            DataEntry(whitelistDataKey, investor)
    ])
    }
}


@Callable(i)
func removeFromWhitelist(investor: String) = {
    let whitelistDataKey = "whitelistedInvestors"
    let whitelistString = getStringValue(this, whitelistDataKey)
    let whitelistStringSize = size(whitelistString)
    if (!isDefined(whitelistString)) then throw("Whitelist is empty")
    else {
        let whitelist = split(whitelistString, ",")
        let investorsCount = size(whitelist)

        let statePrefix = "whitelistedInvestor"
        let stateKey = statePrefix + "-" + investor
        let totalInvKey = "totalInvestors"

        let addressSize = size(investor)
        let addressIndex = extract(indexOf(whitelistString, investor))
        if (addressIndex == 0) then {
            let prefixSize = addressSize + 1
            let newWhitelistString = drop(whitelistString, prefixSize)
            WriteSet([
                DataEntry(stateKey, false),
                DataEntry(totalInvKey, investorsCount - 1),
                DataEntry(whitelistDataKey, newWhitelistString)
            ])
        } else if (addressIndex + addressSize == whitelistStringSize) then {
            let suffixSize = addressSize + 1
            let newWhitelistString = dropRight(whitelistString, suffixSize)
            WriteSet([
                DataEntry(stateKey, false),
                DataEntry(totalInvKey, investorsCount - 1),
                DataEntry(whitelistDataKey, newWhitelistString)
            ])
        } else if whitelistStringSize == addressSize then {
            WriteSet([
                DataEntry(stateKey, false),
                DataEntry(totalInvKey, 0),
                DataEntry(whitelistDataKey, "")
            ])
        } else {
            let prefixSize = addressIndex
            let newPrefix = take(whitelistString, prefixSize)
            let suffixSize = whitelistStringSize - (addressIndex + addressSize + 1)
            let newSuffix = takeRight(whitelistString, suffixSize)
            let newWhitelistString = newPrefix + newSuffix
            WriteSet([
                DataEntry(stateKey, false),
                DataEntry(totalInvKey, investorsCount - 1),
                DataEntry(whitelistDataKey, newWhitelistString)
            ])
        }
    }
}