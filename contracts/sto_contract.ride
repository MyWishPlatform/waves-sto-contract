{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let managementAddress = base58'D_MANAGEMENT_ADDRESS'
let coldVault = extract(addressFromString("D_COLD_VAULT_ADDR"))
let token = base58'D_ASSET_ID'
let tokenRate = D_RATE
let tokenDecimalsOffset = D_DECIMALS_MULTIPLIER
#if defined(D_SOFT_CAP_WAVES) && D_SOFT_CAP_WAVES != 0
let softCapWaves = D_SOFT_CAP_WAVES
#endif
let hardCapTokens = D_HARD_CAP_WAVES
#if defined(D_MIN_INVESTMENT) && D_MIN_INVESTMENT != 0
let minInvestmentWaves = D_MIN_INVESTMENT
#endif
#if defined(D_MAX_INVESTMENT) && D_MAX_INVESTMENT != 0
let maxInvestmentWaves = D_MAX_INVESTMENT
#endif
let startHeight = D_START_DATE
let endHeight = D_FINISH_DATE
let oneWaves = 100000000


func onlyManager(callerBytes: ByteVector) = {
    let caller = toBase58String(callerBytes)
    let managementAddressString = toBase58String(managementAddress)
    if caller != managementAddressString then false else true
}


func hasStarted() = {
    let dataStartHeight = getInteger(this, "startHeight")
    if isDefined(dataStartHeight) then
        let changedStartHeight = extract(dataStartHeight)
        if height < changedStartHeight then false else true
    else
        if height < startHeight then false else true
}


func hasEnded() = {
    let dataEndHeight = getInteger(this, "endHeight")
    if isDefined(dataEndHeight) then
        let changedEndHeight = extract(dataEndHeight)
        if height < changedEndHeight then false else true
    else
        if height < endHeight then false else true
}


func hasFinished() = {
    let isFinalized = getBoolean(this, "finalized")
    if isDefined(isFinalized) then
        extract(isFinalized)
    else
        false
}


func getStartHeight() = {
    let dataStartHeight = getInteger(this, "startHeight")
    if isDefined(dataStartHeight) then
        extract(dataStartHeight)
    else
        startHeight
}


func getEndHeight() = {
    let dataEndHeight = getInteger(this, "endHeight")
    if isDefined(dataEndHeight) then
        extract(dataEndHeight)
    else
        endHeight
}

func getWavesRaised() = {
    let wavesRaised = getInteger(this, "wavesRaised")
    if isDefined(wavesRaised) then
        extract(wavesRaised)
    else
        0
}


func checkInvestorInPage(address: String, page: Int) = {
    let whitelistPageKey = "whitelistedInvestors-" + toString(page)
    let whitelistPage = getString(this, whitelistPageKey)
    if isDefined(whitelistPage)
    then {
        let pageString = extract(whitelistPage)
        let addressPosition = indexOf(pageString, address)
        if isDefined(addressPosition) then true else false
    }
    else
        false
}


func checkInvestorInAllPages(address: String) = {
    if      checkInvestorInPage(address, 0) then true
    else if checkInvestorInPage(address, 1) then true
    else if checkInvestorInPage(address, 2) then true
    else if checkInvestorInPage(address, 3) then true
    else if checkInvestorInPage(address, 4) then true
    else if checkInvestorInPage(address, 5) then true
    else if checkInvestorInPage(address, 6) then true
    else if checkInvestorInPage(address, 7) then true
    else if checkInvestorInPage(address, 8) then true
    else if checkInvestorInPage(address, 9) then true
    else
        false
}


#if defined(D_MIN_INVESTMENT) && D_MIN_INVESTMENT != 0
func getMinInvestment() = {
    let dataMinInvestment = getInteger(this, "minInvestment")
    if isDefined(dataMinInvestment) then
        extract(dataMinInvestment)
    else
        minInvestmentWaves
}
#endif


#if defined(D_MAX_INVESTMENT) && D_MAX_INVESTMENT != 0
func getMaxInvestment() = {
    let dataMaxInvestment = getInteger(this, "maxInvestment")
    if isDefined(dataMaxInvestment) then
        extract(dataMaxInvestment)
    else
        maxInvestmentWaves
}
#endif


@Callable(i)
func buyTokens() = {
    let investorAddress = toBase58String(i.caller.bytes)
    #if defined(D_WHITELIST) && D_WHITELIST != false
    if !checkInvestorInAllPages(investorAddress) then throw("Only for whitelisted")
    else {
    #endif
    let sendedAmount = extract(i.payment).amount
    if (sendedAmount <= 0) then throw("Cannot accept zero value payments")
    #if defined(D_MIN_INVESTMENT) && D_MIN_INVESTMENT != 0
    else if (sendedAmount < getMinInvestment()) then throw("Attached payment is below minimal price")
    #endif
    #if defined(D_MAX_INVESTMENT) && D_MAX_INVESTMENT != 0
    else if (sendedAmount > getMaxInvestment()) then throw("Attached payment is above maximum price")
    #endif
    else if !hasStarted() then throw("STO time is not started yet")
    else if hasEnded() then throw("STO time is already ended")
    else if hasFinished() then throw("STO is finalized")
    else {
        #let wavesRaised = wavesBalance(coldVault)
        let wavesRaised = getWavesRaised()
        let wavesOffset = oneWaves / tokenDecimalsOffset
        let hardCapWaves = hardCapTokens / tokenRate * wavesOffset
        let updatedWavesRaised = wavesRaised + sendedAmount
        if (updatedWavesRaised) > hardCapWaves then
            throw("Attached payment overflows hardcap")
        else {
            let tokenAmount = (sendedAmount * tokenRate) / wavesOffset
            if sendedAmount < wavesOffset then throw("Attached payment is too low to buy unit of token")
            else {
                ScriptResult(
                    WriteSet([
                        DataEntry("wavesRaised", updatedWavesRaised)
                    ]),
                    TransferSet([
                        ScriptTransfer(coldVault, sendedAmount, unit),
                        ScriptTransfer(i.caller, tokenAmount, token)
                    ])
                )
            }
        }
    }
    #if defined(D_WHITELIST) && D_WHITELIST != false
    }
    #endif
}


@Callable(i)
func finalize() = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        if hasFinished() then throw("Already finalized")
        else
            #if defined(D_SOFT_CAP_WAVES) && D_SOFT_CAP_WAVES != 0
            let isReachedSoftCap = wavesBalance(coldVault) >= softCapWaves
            #endif
            #if defined(D_SOFT_CAP_WAVES) && D_SOFT_CAP_WAVES != 0
            if (isReachedSoftCap || hasEnded()) then {
            #else
            if hasEnded() then {
            #endif
                WriteSet([
                    DataEntry("finalized", true)
                ])
            } else {
                throw("STO not finished yet")
            }
    }
}


@Callable(i)
func setStartTime(newStartTime: Int) = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        let currentEndHeight = getEndHeight()
        if (newStartTime > currentEndHeight) then throw("Start date must be lower than end date")
        else {
            WriteSet([
                DataEntry("startHeight", newStartTime)
            ])
        }
    }
}


@Callable(i)
func setEndTime(newEndTime: Int) = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        let currentStartHeight = getStartHeight()
        if (newEndTime > currentStartHeight) then throw("End date must be higher than start date")
        else {
            WriteSet([
                DataEntry("endHeight", newEndTime)
            ])
        }
    }
}


@Callable(i)
func setStartAndEndTimes(newStartTime: Int, newEndTime: Int) = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        # if (newStartTime > endHeight) then throw("Start date must be lower than end date")
        # else if (newEndTime < startHeight) then throw("End date must be higher than start date")
        # else if ((newStartTime <= height) then throw("Cannot set time to past")
        if (newEndTime <= height) then throw("Cannot set time to past")
        else {
            WriteSet([
                DataEntry("startHeight", newStartTime),
                DataEntry("endHeight", newEndTime)
            ])
        }
    }
}


#if defined(D_MIN_INVESTMENT) && D_MIN_INVESTMENT != 0
@Callable(i)
func setMinInvestment(newValue: Int) = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        WriteSet([
            DataEntry("minInvestment", newValue)
        ])
    }
}
#endif


#if defined(D_MAX_INVESTMENT) && D_MAX_INVESTMENT != 0
@Callable(i)
func setMaxInvestment(newValue: Int) = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        WriteSet([
            DataEntry("maxInvestment", newValue)
        ])
    }
}
#endif


#if defined(D_WHITELIST) && D_WHITELIST != false
@Callable(i)
func setWhitelistAddresses(investors: String) = {
    if !(onlyManager(i.caller.bytes)) then throw("Only for administration")
    else {
        let splittedWhitelist = split(investors, ",")
        let newWhitelistSize = size(splittedWhitelist)

        let whitelistDataPrefix = "whitelistedInvestors"
        let totalInvestorsKey = "totalInvestors"
        let currentPageNumKey = "currentWhitelistPage"
        let currentPageSizeKey = "currentWhitelistPageSize"

        let currentWhitelistSize = getInteger(this, totalInvestorsKey)
        if (isDefined(currentWhitelistSize))
        then {
            let currentInvestorsSize = extract(currentWhitelistSize)
            let currentPageNum = getIntegerValue(this, currentPageNumKey)
            let currentPageSize = getIntegerValue(this, currentPageSizeKey)
            let currentWhitelistKey = whitelistDataPrefix + "-" + toString(currentPageNum)
            let currentWhitelistData = getStringValue(this, currentWhitelistKey)

            let remainingPageSize = 100 - currentPageSize
            if ((newWhitelistSize <= remainingPageSize) && (remainingPageSize > 0))
            then {
                let updatedCurrentPageList = currentWhitelistData + "," + investors
                let updatedPageSize = currentPageSize + newWhitelistSize
                let newInvestorsSize = currentInvestorsSize + newWhitelistSize

                WriteSet([
                    DataEntry(totalInvestorsKey, newInvestorsSize),
                    DataEntry(currentPageSizeKey, updatedPageSize),
                    DataEntry(currentWhitelistKey, updatedCurrentPageList)
                ])
            }
            else {
                let newPageNum = currentPageNum + 1
                let newInvestorsSize = currentInvestorsSize + newWhitelistSize
                let newPageSize = newWhitelistSize
                let newWhitelistKey = whitelistDataPrefix + "-" + toString(newPageNum)

                WriteSet([
                    DataEntry(totalInvestorsKey, newInvestorsSize),
                    DataEntry(currentPageNumKey, newPageNum),
                    DataEntry(currentPageSizeKey, newPageSize),
                    DataEntry(newWhitelistKey, investors)
                ])
            }
        }
        else {
            let initPageNum = 0
            let firstPageKey = whitelistDataPrefix + "-" + toString(initPageNum)

            WriteSet([
                DataEntry(totalInvestorsKey, newWhitelistSize),
                DataEntry(currentPageNumKey, initPageNum),
                DataEntry(currentPageSizeKey, newWhitelistSize),
                DataEntry(firstPageKey, investors)
            ])
        }
    }
}
#endif


@Verifier(tx)
func verify() = {
    #if defined(D_DEBUG) && D_DEBUG == true
    true
    #else
    false
    #endif
}